---
title: "[초코레터 리팩토링 - 0] 프로젝트 리팩토링을 하는 이유"
description: "[초코레터 리팩토링 - 0] 프로젝트 리팩토링을 하는 이유"
---
---
## 리팩토링을 하는 이유 

개인 프로젝트를 해야겠다는 생각이 있었다.

하지만, 기획부터 A ~ Z를 하는 프로젝트 보다는 내가 예전에 했던 프로젝트들 중 기획이 괜찮았던 것들을 리팩토링해보고 싶었다.

왜냐하면, 당시의 나 혹은 팀원들이 가지고 있던 지식 내에서 내렸던 의사결정들로 이루어진 프로젝트를 현재 내가 가진 지식, 시각으로 리팩토링하면서 새로운 고민을 하고 의사결정을 내리며 나의 성장 척도를 확인해보고 싶었기 때문이다.

또한, 새로운 것을 만드는 과정은 기존에 내가 하던 습관을 그대로 답습할 확률이 높다.
기존해 했던 것들에 문제점을 찾으면서 이를 개선하는 과정이 나의 성장에 더 큰 도움이 될 것이라고 생각했다.

---
## 초코레터 프로젝트

![chocoletter1](assets/chocoletter1.gif)

### 개요

2025년 발렌타인데이를 타겟으로 시즈널 서비스로 기획하여 진행한 프로젝트이다. (기존 서비스 레포: https://github.com/Son-Hunseo/chocoletter)

간단히 기능을 말하자면, 나의 선물함 링크를 공유하면 해당 링크로 본인의 지인들이 익명으로 편지를 작성해주는 전형적인 익명 편지 서비스였다.
단지 조금 다른점이 있었다면 다음과 같다.

1. 서로 편지를 주고받았다면 2월 14일(발렌타인데이)에 서로 누구인지 추측하는 익명 채팅방이 열린다.
2. 선물을 보낼 때, 일반 편지와 특별 편지를 보낼 수 있는데, 특별 편지의 경우 2월 14일 특정 시간을 지정해 상대방에게 영상통화 초대장을 보낸다.
	- 상대방이 이 초대장을 수락할 경우 해당 시간에 서로를 확인하는 영상통화방이 열린다.


### 기획적 개선점 (영상 통화 기능 삭제)

영상 통화 기능을 제거하는 것이 좋겠다고 생각했다.
왜냐하면, 당시에 1주일정도 서비스를 운영하는 동안 유저는 약 400명 정도였지만, 결국 영상통화 기능을 제대로 사용한 유저는 10명이 될까말까한 인원이었다.
이 이유를 추측해보면 다음과 같다.

1. 서로 얼굴을 마주하는데에 대한 부담
	- 서로 익명인 상태에서 갑자기 얼굴을 드리미는 영상통화가 허들이 높다는 생각이 든다. (보여 주는 것도, 보는 것도)
2. 알림기능의 미흡함
	- 알림 기능의 경우 당시에 팀에서 많은 고민을하고 만들긴했다.
	- 모바일 환경을 가정한 웹 서비스였는데, 휴대폰에 푸시알림을 주기 위해서는 PWA를 선택해야했다.
	- 하지만 이러한 시즈널 서비스에 유저가 앱까지 다운로드 받는 능동을 기대하기는 힘들다.
	- 이에 유입 편의성 vs 확실한 알림을 저울질하며 고민한 끝에 PWA는 하지 않는 것으로 결정했다.
	- 이 대신 유저가 본인의 영상통화 일정을 확인할 수 있는 일정 탭과 30분 전에 일정을 한번 더 리마인드 할 수 있는 알림 탭을 만들었다. (지금 생각해도 웹에서는 이게 최선이었던 것 같다)


또한, 사용률이 떨어지는 부차적 기능을 위해 소모하는 리소스가 너무 많다.

1. 영상통화 기능을 매개해주기 위한 Openvidu 라는 오픈 소스를 호스팅 해야한다. (인프라적 리소스 낭비)
2. 이 부차적인 영상통화라는 기능을 받쳐주기위한 부가 기능이 너무 많다.
	- 프론트엔드
		- 일정 탭
		- 알림 탭
		- 선물 타입(영상통화 or 일반) 선택 분기
		- 영상 통화 화면
	- 백엔드
		- 영상통화 일정 관리
		- 스케줄링 작업을 일정 시간마다 돌리면서 db 전체를 조회하고 이를 알림
		- 영상 통화 매개

이러한 이유들로 영상 통화 기능을 삭제해야겠다고 생각했다.

### 기술적 개선점 (Kafka to Redis, 코드 리팩토링)

**[Kafka to Redis]**

당시에 채팅방 기능을 구현하기 위해 `Kafka`를 사용했다.
채팅 기능 자체의 중요성에 비해 공부하는 학생이었기 때문에 설계를 꽤나 열심히 했다.
'대규모 시스템 설계 기초' 책에 나오는 채팅 시스템 설계를 참고하여 아키텍처를 구성했다.

채팅 기능의 부하가 메인 기능에 전이되는 것을 막기 위해 채팅 기능만 매개하는 백엔드 서버를 따로 두었고, 트래픽 증가시 버퍼 역할, 순서 보장, 유실 방지, 확장성 과 같은 측면을 고려하여 메시지 큐를 도입하였다.

이러한 아키텍처 자체는 지금 봐도 문제가 없어보인다.
단지, 1:1 채팅방이라는 간단한 기능에서 `Kafka`와 같은 비교적 무거운 메시지 큐를 사용해야하는지에 대한 의문이 든다.

당시에는 '`Kafka`라는 기술을 한번 사용해보고싶어서' 라는 이유가 가장 컸던 것 같다.
이에 목적에 맞는 기술 스택 선택(닭잡는데 소잡는 칼을 사용할 필요는 없다)이 좋다고 생각하여 `Redis`로 기술 스택을 바꿔야겠다고 생각했다.


**[코드 리팩토링]**

앞에 여러 기능들을 설명했듯이 각 기능들이 다른 기능에 얽히고 섥혀있어 백엔드 코드에서 여러 기능과 도메인들이 섞여있다.

예를들어 우리 서비스에서 A라는 도메인의 컨트롤러가 B라는 도메인의 서비스를 참조한다던가 하는 코드들이 존재한다.

이러한 코드들은 프로젝트 기간이 정해져있기 때문에 속도적인 측면에서는 유리하나 강한 결합 문제, 순환 참조 문제 등이 발생할 수 있다. (실제로 순환 참조 문제가 발생해서 이를 디버깅 했던 기억이 있다)

이에 이러한 코드들을 개선하는 것 또한 좋은 작업이라고 생각해서 코드 리팩토링을 진행해야겠다고 생각했다.


### 기술적 오류 (암호화)

당시에 꽂힌 부분은 "이거 개발자들은 편지 내용 다 볼수 있는거 아니에요? 그러면 쓰기 싫은데.." 라는 피드백이다.

이에 "우리도 볼 수 없어야해!"에 매몰되어서 잘못된 암호화 로직을 사용했다. (오히려 더 취약하다)

당시에 사용했던 암호화 로직은 다음과 같다.

- 편지 내용을 복호화하는 키는 대칭키이다.
	- 대칭키는 프론트엔드 코드에서 가지고 있다.
- 로그인 시점 (로그인 할때마다) 
	- 프론트엔드에서 비대칭키를 생성하고 대칭키를 공개키로 암호화해서 서버에 저장한다.
- 편지 전송
	- 대칭키로 편지를 암호화한다. 해당 암호화한 값을 서버로 보내 서버에서는 해당 암호화된 편지 내용을 저장한다.
- 편지 조회
	- 서버에서 (대칭키로)암호화된 편지 내용과 (비대칭키로)암호화된 대칭키를 받는다.
	- 내 개인키로 암호화된 대칭키를 복호화해서 대칭키를 얻는다. (사실 이럴 필요도 없다 프론트엔드에 대칭키가 박혀있어서)
	- 이 대칭키로 편지 내용을 복호화해서 볼 수 있다.

위 암호화 로직은 완전히 잘못됐다.
마감 하루 전날에 잘 알지 못하는 암호화 로직을 구현하면서 "개발자가 보지 못하는 구조"를 만들려고 억지로 만들다보니 위와같이 이상한 암호화 구조가 만들어진 것이다.

아래와 같은 문제점을 가진다.

1. 개발자가 볼 수 있다. (프론트엔드 코드에 대칭키가 박혀있음)
2. 브라우저에 박혀있으므로 누구나 암호화된 편지를 복호화할 수 있다.
3. 결과적으로 원하는 목적을 달성하지 못하며 평문으로 보내는 것과 별 다를게 없는 이상한 로직이다.

대칭키를 비대칭키로 암호화해서 키교환(혹은 디피-헬만과 같은 공통키 생성 알고리즘 사용)하는 구조는 많이 사용하는 구조이지만, 이 사례에서 사용하기 적절한 구조는 아니다.

- 왜냐하면, 위와같은 암호화 사용 사례는 SSL 통신과 같은 과정에서 서로 같은 대칭키를 안전하게 교환하여 중간에 탈취자가 데이터를 보지 못하게하는 구조이다.
- 데이터를 교환하는 주체 2명 중 1명이 보지 못하게하는 구조가 아니다. (그렇게 되지도 않고)

그래서 어떻게 해야할까?

1. 프론트엔드에서 보낼 때는 평문으로 보낸다.
2. 백엔드에서 대칭키로 암호화해서 DB에 저장한다.
	- 비대칭키는 일반적인 데이터를 암호화하기에 비효율적이다.
3. 해당 대칭키는 안전하게 소수의 인원만 접근할 수 있게 보관한다. (극소수의 인원 접근 가능)

위처럼 관리하는 것이 맞다.

이에 이전의 이상한 암호화 알고리즘은 아예 걷어내는 것이 맞다.

---
## 기록

이러한 리팩토링 과정들을 블로그에 글로써 남기려고한다.

리팩토링을 해야지라고 마음먹고 프로젝트를 다시 들여다보며 느낀 점 중 하나는 당시에 의사결정들이 희미하게는 기억나지만, 어떠한 의도, 회의 과정을 거쳐서 개발을 했는지에 대한 기록이 남아있지 않아 아쉬웠다.

이에 리팩토링 과정을 기록하며 몇년 후 성장한 내가 다시 이 과정을 보았을 때 느끼는 점이 있을 것이라 생각하여 기록하게 되었다.